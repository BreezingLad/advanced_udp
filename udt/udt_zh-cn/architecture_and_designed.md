
2.架构设计

UDT/CCC 库可以看成应用层和网络传输层的中间层. 它可以看成UDP协议的应用程序。在这一部分，我们主要探讨UDT提供的拥塞控制接口，以及在UDT层是如何实现的。

2.1 概述
UDT架构是分层的，将图1. UDT 底层使用由操作系统提供的socket接口实现的UDP协议。它为应用程序提供一套UDT接口。
应用程序可以像调用系统socket接口那样调用UDTsocket接口。用户可以通过提供一个拥塞控制的接口类给UDT控制事件（进行拥塞控制），也可以使用UDT默认的拥塞控制算法。CC模块定义了需要用户实现的回调函数集，以便UDT能够控制某方面的事件。

2.2 CCC 接口
UDT 将拥塞控制机制分成了4个可配置部分。分别是：1）事件控制句柄回调、2）协议行为配置、3）包扩展、4）性能监控。
2.2.1 事件控制回调
	CCC类定义了7个基本的回调函数。当相应的事件发生时，UDT就会回调它。
	init 和 close: 这两个函数分别在UDT建立连接、连接断开的时候调用。它们可以用来保证必要数据结构的分配和释放。
	onACK: 该函数在发送方收到ACK时调用。用户可以通过该函数的参数，得知确认报文的序列号。
	onLoss: 该函数在发送方丢失报文时调用。onLoss接口参数提供了明确的（报文）丢失信息。值得注意的是，大多时候对于TCP的(可靠)算法, 使用重复ACK来确定报文的丢失可能是多余的[1]。
	UDT 通过产生负ACK号（NAK）来明确报告（报文）丢失信息。这与选择确认机制是等价的。
	onTimeout: 一次事件超时会触发该回调函数。用户可以指定超时时间，否则将使用默认的超时时间——默认的超时时间使用TCP RTO 的计算方式，具体计算方法参见RFC 2988.
	onPktSent: 该函数在报文被发送时回调。通过该函数参数，用户可以访问该报文所以信息（比如，序列号、时间戳、大小等）。
	onPktReceived:该函数在报文被接收到后回调。和onPktSent一样，用户可以通过该函数参数访问接收报文的所有信息。
	onPktSent 和 onPktReceived 是两个非常有用的事件处理函数，因为它可以让用户检查每个底层报文。例如，onPktRecieved可以用来计算在TFRC中的丢包率。同样，用户可以用这两个回调函数来跟踪该协议的细节。
	processCustomMsg:UDT使用该方法来处理用户自定义的控制消息。
2.2.2 协议配置
	为了使用某个控制算法，协议的某些行为需要个性化。例如，某个控制算法与数据包的确认机制有很大关系. UDT/CCC 为这种需求提供了必要的协议配置API。
	用户可以在接收端自定义如何确认收到的报文。setACKTimer/setAckInterval分别定义了接收报文后的延迟和接收到的报文数据，这定义了UDT确认报文的频率。
	sendCustomMsg 发送由processCustomMsg处理后的用户自定义的控制报文到UDT连接的对端。它支持像TFRC这种 需要产生自己的控制报文协议。
	最后，UDT/CCC 也支持用户修改RTT和RTO的值。一个新的拥塞控制算法既可以选择UDT计算的RTT的值，也可以自己计算的RTT。同意，RTO的计算方式也可以重新定义。
	UDT协议还有一些其它特性，虽然和拥塞控制无关，但是对其它控制算法很有用。比如，选择确认（SACK）、稳定的重排，CCC用户不能配置，但有些可以通过UDT接口配置。
2.2.3 包扩展
	一个可配置的协议栈支持用户自定义控制报文是很有必要的。、
	由于UDT/CCC库主要处理拥塞控制算法，所以对控制报文的个性化比较少。因为数据包处理本身是CPU密集型计算，故个性化的数据包容易造成性能降低。
	
	UDT协议在UDP协议头上，增加一个基于包的序列号和一个相应的精确到毫秒的时间戳（从连接建立开始计时），见表2。大多数算法，对于这些信息就已经足够了。
	当然，用户可以通过UDT控制报文头（见表2）中的Type 2字段来自定义控制报文。报文携带的详细控制信息由该报文类型决定。在接收端，用户只需要重写processCustomMsg, 告诉UDT/CCC如何处理该新类型的报文即可。
	值得注意的是，UDP 提供的包大小信息，使基于包的UDT的序号与基于字节流的TCP的序列号等价，这使得UDT也能支持字节流传输。
2.2.3 性能监控。
	
	 
	
[1] TCP采用超时定时器，使用超时机制来确定是否发生报文丢失。如果超时了会重传报文，此时如果两个报文都没有丢失就可能回送多个ACK。但是，“超时”我们就已经确认了报文丢失，而“收到多个ACK”只是报文丢失中的一小部分。
	