
1.kcp 官方文档来看，丢包后的RTO会乘以1.5；从代码来看，无延迟的情况下还是会翻倍的!
2.ikcp_input函数中，如果传入比较小的包，会直接返回-1,可以有多次返回吧？
    再一想这个函数，返回-1说明包头还没有接收完成，返回-2是包还没有接收完成。这两个都可以通过上层检测重新接收来完成。
3.ikcp_recv也会有三种情况：
    -1：接收队列为空，如果是刚成功调用ikcp_input后是不会出现的，但是如果是异步执行就可能发生。
    -2：最后一个分片还没有接收到。
    -3: 接收缓冲区太小，调用ikcp_peeksize取得包大小。
4.会话的保存要具有唯一性，如果对端发过来的数据被认为是另外一个已有连接，由于序列号机制，很可能会把报文丢弃。
    一个很好的场景构造就是：对端发送固定的conv，服务端采用IP区分客户端。此时只要客户端运行两次，第二次客户端就收不到应答——服务端认为是重发报文
